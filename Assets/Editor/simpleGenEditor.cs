
//C# Example
using UnityEditor;
using UnityEngine;

public class simpleGenEditor: EditorWindow
{
	// Add menu item named "My Window" to the Window menu
	[MenuItem("Window/SimpleLevelGeneration")]

	public static void ShowWindow()
	{
		//Show existing window instance. If one doesn't exist, make one.
		EditorWindow.GetWindow(typeof(simpleGenEditor));
	}

	//Varibles
	public int wallSize=5;
	public Texture2D[] layer; //Iamge Array
	
	void OnGUI()
	{

		GUILayout.Label ("Settings", EditorStyles.boldLabel);
		wallSize = EditorGUILayout.IntField("Wall size",wallSize);


		//Finds the layer array in  this script to be serialized
		//Creates an array interface for the serialized object
		ScriptableObject target = this;

		SerializedObject so = new SerializedObject(target);
		SerializedProperty stringsProperty = so.FindProperty("layer");
		
		EditorGUILayout.PropertyField(stringsProperty, true); // True means show children
		so.ApplyModifiedProperties(); // Remember to apply modified properties

		GUILayout.Label ("Actions", EditorStyles.boldLabel);


		//Buttons 
		//Calls the generate function to creat the level from the image(s)
		if (GUILayout.Button("Generate"))
		{
			if(CountLevelSize()>5000)
			{
				//Dialog Box, Yes returns true and Generates level
				if(EditorUtility.DisplayDialog("LargeImageSize","Large image size has been detected. " +
								"This may take a long time to generate. Proceed?","Ok","Cancel") ==true)
				{
					Generate();
				}
			}
			else
			{
				Generate();
			}
		}

		//Clears the array of blueprint images
		if (GUILayout.Button("Clear Images"))
		{
			System.Array.Clear(layer,0,layer.Length);

		}

		//Deletes  the gameobjects that were generated by this script
		if (GUILayout.Button("Delete Level"))
		{
			foreach(GameObject levelObject in GameObject.FindGameObjectsWithTag("Generated"))
			{
				DestroyImmediate(levelObject);
			}
		}

	}

	void Generate()
	{
		int arraySize = layer.Length;
		//Layer iterator (Selects which floor to draw)
		for(int l=0;l<arraySize;l++)
		{
			//Game object that will be used as a building block
			GameObject cube;
			
			//Layer Select
			Texture2D blueprint = layer[l];
			
			//Size of image in width/Height
			int maxH = blueprint.height;
			int maxW= blueprint.width;

			
			//Starting height depending on layer selected
			float layerHeight = (wallSize) *l-(l);
			
			//Iterators for pixel selection
			int i;
			int j;
			
			//check for image size
			//Small image
				//Full loop to read through each pixel
				for(i=0;i<maxW;i++)
				{
					for(j=0;j<maxH;j++)
					{
						//Get the color of the pixel (Pix = current pixel colour data)
						Color pix = blueprint.GetPixel(i,j);
						
						//Colour checks with tollerance see "colourCompare" function(returns colour) 
						//
						//Check for blank pixels, performs an action if that pixel has colour
						if(colourCompare(pix) != Color.clear)
						{
							//RED:Creates a Window 
							if(colourCompare(pix)== Color.red)
							{
								//Bottom half of window
								cube = GameObject.CreatePrimitive (PrimitiveType.Cube);
								
								cube.transform.localScale = new Vector3(1,(wallSize/2),1);
								cube.transform.position = new Vector3(i,layerHeight+(wallSize/4),j);
								cube.name = "cube"+i+j+"DoorBot";
								cube.tag = "Generated";
								cube.GetComponent<Renderer>().material.color = pix;
								
								//Top half of window
								cube = GameObject.CreatePrimitive (PrimitiveType.Cube);	
								cube.transform.localScale = new Vector3(1,(wallSize/2),1);
								cube.transform.position = new Vector3(i,layerHeight+(wallSize)-(wallSize/4),j);
								cube.name = "cube"+i+j+"DoorTop";
								cube.tag = "Generated";
								cube.GetComponent<Renderer>().material.color = pix;
							}
							
							//GREEN:Creates Grass
							if(colourCompare(pix)== Color.green)
							{
								//do green things
								
							}
							//BLUE:Creates Water
							if(colourCompare(pix)== Color.blue)
							{
								//do blue things
								
							}
							
							//CYAN
							if(colourCompare(pix)== Color.cyan)
							{
								
							}
							//MAGENTA
							if(colourCompare(pix)== Color.magenta)
							{
								
							}
							//YELLOW
							if(colourCompare(pix)== Color.yellow)
							{
								
							}
							
							//WHITE:Creates Floor
							if(colourCompare(pix)== Color.white)
							{
								cube = GameObject.CreatePrimitive (PrimitiveType.Cube);
								cube.transform.position = new Vector3(i,layerHeight+0.5f,j);
								
								cube.name = "cube"+i+j+"Floor";
								cube.tag = "Generated";
								cube.GetComponent<Renderer>().material.color = pix;
								
							}
							//GREY: CreatesFloor and Ceiling 
							if(colourCompare(pix)== Color.grey)
							{
								//Floor
								cube = GameObject.CreatePrimitive (PrimitiveType.Cube);
								cube.transform.position = new Vector3(i,layerHeight + 0.5f,j);
								cube.name = "cube"+i+j+"Floor";
								cube.tag = "Generated";
								cube.GetComponent<Renderer>().material.color = pix;
								
								
								//Ceiling
								cube = GameObject.CreatePrimitive (PrimitiveType.Cube);
								cube.transform.position = new Vector3(i,layerHeight+(-0.5f+wallSize),j);
								cube.name = "cube"+i+j+"Ceilng";
								cube.tag = "Generated";
								cube.GetComponent<Renderer>().material.color = pix;
							}
							
							
							//BLACK:Creates Wall (Height dependant on alpha value)
							//Can be used to create "stairs"
							if(colourCompare(pix)== Color.black)
							{			
								cube = GameObject.CreatePrimitive (PrimitiveType.Cube);
								cube.transform.localScale = new Vector3(1,(wallSize*pix.a),1);
								cube.transform.position = new Vector3(i,layerHeight+((wallSize*pix.a)/2), j);
								
								cube.name = "cube"+i+j+"wall";
								cube.tag = "Generated";
								cube.GetComponent<Renderer>().material.color = pix;
							}	
						}
					}
				}
		}
	}

	//Converts colours that are borderline to Unity standars colours so they can be easily checked
	Color colourCompare(Color colourToCheck)
	{
		//RED
		if (colourToCheck.r >= 0.9f && colourToCheck.g <= 0.1f && colourToCheck.b <= 0.1f && colourToCheck.a >= 0.9f)
		{
			return Color.red;
		}
		
		//GREEN
		if (colourToCheck.r <= 0.1f && colourToCheck.g >= 0.9f && colourToCheck.b <= 0.1f && colourToCheck.a >= 0.9f)
		{
			return Color.green;
		}
		
		//BLUE
		if (colourToCheck.r <= 0.1f && colourToCheck.g <= 0.1f && colourToCheck.b >= 0.9f && colourToCheck.a >= 0.9f)
		{
			return Color.blue;
		}
		
		//WHITE
		if (colourToCheck.r >= 0.9f && colourToCheck.g >= 0.9f && colourToCheck.b >= 0.9f && colourToCheck.a >= 0.9f)
		{
			return Color.white;
		}
		
		//BLACK
		if(colourToCheck.r <= 0.1f && colourToCheck.g <= 0.1f && colourToCheck.b <= 0.1f&&colourToCheck.a >= 0.2f)
		{
			return Color.black;
		}
		
		//CYAN
		if(colourToCheck.r <= 0.1f && colourToCheck.g >= 0.9f && colourToCheck.b >= 0.9f && colourToCheck.a >= 0.9f)
		{
			return Color.cyan;
		}
		
		//MAGENTA
		if(colourToCheck.r >= 0.9f && colourToCheck.g <= 0.1f && colourToCheck.b >= 0.9f && colourToCheck.a >= 0.9f)
		{
			return Color.magenta;
		}
		
		//YELLOW
		if(colourToCheck.r >= 0.9f && colourToCheck.g >= 0.9f && colourToCheck.b <= 0.1f && colourToCheck.a >= 0.9f)
		{
			return Color.yellow;
		}
		
		
		//GREY
		if(colourToCheck.r < 0.6f && colourToCheck.r > 0.4f && 
		   colourToCheck.g < 0.6f && colourToCheck.g > 0.4f && 
		   colourToCheck.b < 0.6f && colourToCheck.b > 0.4f &&
		   colourToCheck.a >= 0.09f)
			
		{
			return Color.grey;
		}
		
		//NON DEFINED COLOURS
		else
		{
			return Color.clear;
		}
	}

	//Returns the number of Pixels in the entire array
	int CountLevelSize()
	{
		int levelSize=0;
		int layerSize=0;
		int arraySize = layer.Length;

		for(int l=0;l<arraySize;l++)
		{
			Texture2D blueprint = layer[l];

			int maxH = blueprint.height;
			int maxW = blueprint.width;
			layerSize = maxW*maxH;

			levelSize = levelSize + layerSize;

		}
		return levelSize;
	}



}
